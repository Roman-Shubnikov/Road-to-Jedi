import _extends from "@babel/runtime/helpers/extends";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
import React, { useRef, useEffect, useState, useCallback } from 'react';
import classNames from '../../lib/classNames';
import usePlatform from '../../hooks/usePlatform';
import getClassName from '../../helpers/getClassName';
import withAdaptivity from '../../hoc/withAdaptivity';
import HorizontalScrollArrow from './HorizontalScrollArrow';

/**
 * ease function
 * @param x absolute progress of the animation in bounds 0 (beginning) and 1 (end)
 */
function easeInOutSine(x) {
  return 0.5 * (1 - Math.cos(Math.PI * x));
}
/**
 * timing method
 */


function now() {
  return performance && performance.now ? performance.now() : Date.now();
}
/**
 * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll
 * Константа взята из полифила (468), на дизайн-ревью уточнили до 250
 * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла
 */


var SCROLL_ONE_FRAME_TIME = 250;

function doScroll(_ref) {
  var scrollElement = _ref.scrollElement,
      getScrollPosition = _ref.getScrollPosition,
      animationQueue = _ref.animationQueue,
      onScrollToRightBorder = _ref.onScrollToRightBorder,
      onScrollEnd = _ref.onScrollEnd,
      onScrollStart = _ref.onScrollStart,
      initialScrollWidth = _ref.initialScrollWidth,
      _ref$scrollAnimationD = _ref.scrollAnimationDuration,
      scrollAnimationDuration = _ref$scrollAnimationD === void 0 ? SCROLL_ONE_FRAME_TIME : _ref$scrollAnimationD;

  if (!scrollElement || !getScrollPosition) {
    return;
  }
  /**
   * максимальное значение сдвига влево
   */


  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;
  var startLeft = scrollElement.scrollLeft;
  var endLeft = getScrollPosition(startLeft);
  onScrollStart();

  if (endLeft >= maxLeft) {
    onScrollToRightBorder();
    endLeft = maxLeft;
  }

  var startTime = now();

  (function scroll() {
    if (!scrollElement) {
      onScrollEnd();
      return;
    }

    var time = now();
    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);
    var value = easeInOutSine(elapsed);
    var currentLeft = startLeft + (endLeft - startLeft) * value;
    scrollElement.scrollLeft = Math.ceil(currentLeft);

    if (scrollElement.scrollLeft !== Math.max(0, endLeft)) {
      requestAnimationFrame(scroll);
      return;
    }

    onScrollEnd();
    animationQueue.shift();

    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  })();
}

var HorizontalScroll = function HorizontalScroll(props) {
  var children = props.children,
      getScrollToLeft = props.getScrollToLeft,
      getScrollToRight = props.getScrollToRight,
      _props$showArrows = props.showArrows,
      showArrows = _props$showArrows === void 0 ? false : _props$showArrows,
      scrollAnimationDuration = props.scrollAnimationDuration,
      className = props.className,
      hasMouse = props.hasMouse,
      restProps = _objectWithoutProperties(props, ["children", "getScrollToLeft", "getScrollToRight", "showArrows", "scrollAnimationDuration", "className", "hasMouse"]);

  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      canScrollLeft = _useState2[0],
      setCanScrollLeft = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      canScrollRight = _useState4[0],
      setCanScrollRight = _useState4[1];

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      initialScrollWidth = _useState6[0],
      setInitialScrollWidth = _useState6[1];

  var isCustomScrollingRef = useRef(false);
  var scrollerRef = useRef(null);
  var animationQueue = useRef([]);
  var platform = usePlatform();

  function scrollTo(getScrollPosition) {
    animationQueue.current.push(function () {
      return doScroll({
        scrollElement: scrollerRef.current,
        getScrollPosition: getScrollPosition,
        animationQueue: animationQueue.current,
        onScrollToRightBorder: function onScrollToRightBorder() {
          return setCanScrollRight(false);
        },
        onScrollEnd: function onScrollEnd() {
          return isCustomScrollingRef.current = false;
        },
        onScrollStart: function onScrollStart() {
          return isCustomScrollingRef.current = true;
        },
        initialScrollWidth: initialScrollWidth,
        scrollAnimationDuration: scrollAnimationDuration
      });
    });

    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }

  var onscroll = useCallback(function () {
    if (showArrows && hasMouse && scrollerRef.current && !isCustomScrollingRef.current) {
      setCanScrollLeft(scrollerRef.current.scrollLeft > 0);
      setCanScrollRight(scrollerRef.current.scrollLeft + scrollerRef.current.offsetWidth < scrollerRef.current.scrollWidth);
    }
  }, [hasMouse]);
  useEffect(function () {
    scrollerRef.current && scrollerRef.current.addEventListener('scroll', onscroll);
    scrollerRef.current && setInitialScrollWidth(scrollerRef.current.scrollWidth);
    return function () {
      return scrollerRef.current && scrollerRef.current.removeEventListener('scroll', onscroll);
    };
  }, []);
  useEffect(onscroll, [scrollerRef]);
  return /*#__PURE__*/React.createElement("div", _extends({}, restProps, {
    className: classNames(className, getClassName('HorizontalScroll', platform))
  }), showArrows && hasMouse && canScrollLeft && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {
    direction: "left",
    onClick: function onClick() {
      return scrollTo(getScrollToLeft);
    }
  }), showArrows && hasMouse && canScrollRight && /*#__PURE__*/React.createElement(HorizontalScrollArrow, {
    direction: "right",
    onClick: function onClick() {
      return scrollTo(getScrollToRight);
    }
  }), /*#__PURE__*/React.createElement("div", {
    className: "HorizontalScroll__in",
    ref: scrollerRef
  }, /*#__PURE__*/React.createElement("div", {
    className: "HorizontalScroll__in-wrapper"
  }, children)));
};

export default withAdaptivity(HorizontalScroll, {
  hasMouse: true
});
//# sourceMappingURL=HorizontalScroll.js.map